package com.magmaguy.freeminecraftmodels.customentity.core;

import com.magmaguy.easyminecraftgoals.NMSManager;
import com.magmaguy.easyminecraftgoals.internal.PacketModelEntity;
import com.magmaguy.freeminecraftmodels.config.DefaultConfig;
import com.magmaguy.freeminecraftmodels.dataconverter.BoneBlueprint;
import com.magmaguy.freeminecraftmodels.utils.TransformationMatrix;
import com.magmaguy.freeminecraftmodels.utils.VersionChecker;
import lombok.Getter;
import org.bukkit.Location;
import org.bukkit.util.EulerAngle;
import org.bukkit.util.Vector;
import org.joml.Vector3f;

public class BoneTransforms {

    private final Bone parent;
    private final Bone bone;
    private final TransformationMatrix boneMatrix = new TransformationMatrix();
    //This matrix belongs to an autogenerated root bone
    private TransformationMatrix entityMatrix = new TransformationMatrix();
    @Getter
    private PacketModelEntity packetArmorStandEntity = null;
    @Getter
    private PacketModelEntity packetDisplayEntity = null;

    public BoneTransforms(Bone bone, Bone parent) {
        this.bone = bone;
        this.parent = parent;
    }

    public void transform() {
        updateBoneMatrix();
        updateEntityMatrix();
    }

    public void updateBoneMatrix() {
        boneMatrix.resetToIdentityMatrix();

        Vector3f blueprintModelPivot = bone.getBoneBlueprint().getBlueprintModelPivot();

        // 1. Translate to pivot point
        boneMatrix.translateLocal(blueprintModelPivot);

        // 2. Apply rotations (default + animation)
        //Default rotation - should be local as per BlockBench
        boneMatrix.rotateLocal(bone.getBoneBlueprint().getBlueprintOriginalBoneRotation());

        //animation rotation
        boneMatrix.rotateLocal(
                bone.getAnimationRotation().get(0),
                bone.getAnimationRotation().get(1),
                bone.getAnimationRotation().get(2));

        // 3. Scale (moved here)
        boneMatrix.scale(getDisplayEntityScale() / 2.5f); //todo reenable once other things are fixed

        // 4. Translate back from pivot point
        boneMatrix.translateLocal(blueprintModelPivot.mul(-1));

        // 5. Translate to model center - should be local as per BlockBench
        boneMatrix.translateLocal(bone.getBoneBlueprint().getModelCenter());

        // 6. Apply animation translation
        boneMatrix.translateLocal(
                bone.getAnimationTranslation().get(0),
                bone.getAnimationTranslation().get(1),
                bone.getAnimationTranslation().get(2));

        // 7. Handle parent model center offset
        if (parent != null) {
            Vector3f correctedModelCenter = new Vector3f(parent.getBoneBlueprint().getModelCenter()).mul(-1);
            boneMatrix.translateLocal(correctedModelCenter);
        }
    }

    public void updateEntityMatrix() {
        if (parent == null) {
            Location currentLocation = bone.getSkeleton().getCurrentLocation();
//            boneMatrix.rotateGlobalY((float) Math.toRadians(currentLocation.getYaw()));
//            boneMatrix.rotateGlobalY((float) Math.toRadians(currentLocation.getYaw() + 180));
//            boneMatrix.scale(-1.0f, 1f, -1f);
            boneMatrix.translateGlobal((float) currentLocation.getX(), (float) currentLocation.getY(), (float) currentLocation.getZ());
            entityMatrix.getMatrix().set(boneMatrix.getMatrix());
        } else {
            TransformationMatrix.multiplyMatrices(parent.getBoneTransforms().entityMatrix, boneMatrix, entityMatrix);
            //todo: this is going to have to be remade
//            if (bone.getBoneBlueprint().isHead()) {
//                entityMatrix.resetRotation();
//                float yaw = -bone.getSkeleton().getCurrentHeadYaw() + 180;
//                entityMatrix.rotateY((float) Math.toRadians(yaw));
//                entityMatrix.rotateX(-(float) Math.toRadians(bone.getSkeleton().getCurrentHeadPitch()));
//            }
        }
    }

    public void generateDisplay() {
        if (bone.getBoneBlueprint().isDisplayModel()) {
            initializeDisplayEntityBone();
            initializeArmorStandBone();
        }
    }

    private void initializeDisplayEntityBone() {
        if (!DefaultConfig.useDisplayEntitiesWhenPossible) return;
        Location displayEntityLocation = getDisplayEntityTargetLocation();
        packetDisplayEntity = NMSManager.getAdapter().createPacketDisplayEntity(displayEntityLocation);
        if (VersionChecker.serverVersionOlderThan(21, 4))
            packetDisplayEntity.initializeModel(displayEntityLocation, Integer.parseInt(bone.getBoneBlueprint().getModelID()));
        else
            packetDisplayEntity.initializeModel(displayEntityLocation, bone.getBoneBlueprint().getModelID());
        sendDisplayEntityUpdatePacket();
    }

    private void initializeArmorStandBone() {
        //todo: add way to disable armor stands later via config
        packetArmorStandEntity = NMSManager.getAdapter().createPacketArmorStandEntity(getArmorStandTargetLocation());
        if (VersionChecker.serverVersionOlderThan(21, 4))
            packetArmorStandEntity.initializeModel(getArmorStandTargetLocation(), Integer.parseInt(bone.getBoneBlueprint().getModelID()));
        else
            packetArmorStandEntity.initializeModel(getArmorStandTargetLocation(), bone.getBoneBlueprint().getModelID());
        sendArmorStandUpdatePacket();
    }

    protected Location getArmorStandTargetLocation() {
        // Get translation directly from the matrix
        float[] translation = entityMatrix.getTranslation();

        Location armorStandLocation = new Location(
                bone.getSkeleton().getCurrentLocation().getWorld(),
                translation[0],
                translation[1],
                translation[2]
        );

        // Apply armor stand offset
        armorStandLocation.subtract(new Vector(0, BoneBlueprint.getARMOR_STAND_PIVOT_POINT_HEIGHT(), 0));
        return armorStandLocation;
    }

    protected Location getDisplayEntityTargetLocation() {
        // Get translation from global matrix
        float[] translation = entityMatrix.getTranslation();

        return new Location(
                bone.getSkeleton().getCurrentLocation().getWorld(),
                translation[0],
                translation[1],
                translation[2]
        );
    }

    protected EulerAngle getDisplayEntityRotation() {
        float[] rotation = entityMatrix.getRotation();

//        // For all actual bone entities (non-root)
//        if (parent != null) {
//            // For a 180° Y rotation:
//            rotation[0] = -rotation[0];  // Invert X rotation
//            rotation[1] = rotation[1] + (float) Math.PI;  // Add 180° to Y
//            rotation[2] = -rotation[2];  // Invert Z rotation
//
//            // Normalize Y rotation to keep it in -π to π range
//            if (rotation[1] > Math.PI) {
//                rotation[1] -= 2 * Math.PI;
//            } else if (rotation[1] < -Math.PI) {
//                rotation[1] += 2 * Math.PI;
//            }
//        }

        return new EulerAngle(rotation[0], rotation[1], rotation[2]);
    }

    protected EulerAngle getArmorStandEntityRotation() {
        float[] rotation = entityMatrix.getRotation();

        // For all actual bone entities (non-root)
        if (parent != null) {
            // For a 180° Y rotation:
            rotation[0] = -rotation[0];  // Invert X rotation
            rotation[1] = rotation[1] + (float) Math.PI;  // Add 180° to Y
            rotation[2] = -rotation[2];  // Invert Z rotation

            // Normalize Y rotation to keep it in -π to π range
            if (rotation[1] > Math.PI) {
                rotation[1] -= 2 * Math.PI;
            } else if (rotation[1] < -Math.PI) {
                rotation[1] += 2 * Math.PI;
            }
        }

        return new EulerAngle(rotation[0], rotation[1], rotation[2]);
    }

    protected float getDisplayEntityScale() {
        return bone.getAnimationScale() == -1 ? 2.5f : bone.getAnimationScale() * 2.5f;
    }

    public void sendUpdatePacket() {
        sendArmorStandUpdatePacket();
        sendDisplayEntityUpdatePacket();
    }

    private void sendArmorStandUpdatePacket() {
        if (packetArmorStandEntity != null) {
            packetArmorStandEntity.sendLocationAndRotationPacket(getArmorStandTargetLocation(), getArmorStandEntityRotation());
        }
    }

    private void sendDisplayEntityUpdatePacket() {
        if (packetDisplayEntity != null) {
            Location testLocation = getDisplayEntityTargetLocation();
            testLocation.setYaw(180);
            packetDisplayEntity.sendLocationAndRotationAndScalePacket(testLocation, getDisplayEntityRotation(), getDisplayEntityScale());
        }
    }

}
