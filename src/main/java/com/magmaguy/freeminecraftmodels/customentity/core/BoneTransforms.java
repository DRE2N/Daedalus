package com.magmaguy.freeminecraftmodels.customentity.core;

import com.magmaguy.easyminecraftgoals.NMSManager;
import com.magmaguy.easyminecraftgoals.internal.PacketModelEntity;
import com.magmaguy.freeminecraftmodels.config.DefaultConfig;
import com.magmaguy.freeminecraftmodels.dataconverter.BoneBlueprint;
import com.magmaguy.freeminecraftmodels.utils.CoordinateSystemConverter;
import com.magmaguy.freeminecraftmodels.utils.TransformationMatrix;
import com.magmaguy.freeminecraftmodels.utils.VersionChecker;
import lombok.Getter;
import org.bukkit.Location;
import org.bukkit.util.EulerAngle;
import org.bukkit.util.Vector;
import org.joml.Vector3f;

public class BoneTransforms {

    private final Bone parent;
    private final Bone bone;
    private final TransformationMatrix localMatrix = new TransformationMatrix();
    //This matrix belongs to an autogenerated root bone
    private final TransformationMatrix globalMatrix = new TransformationMatrix();
    @Getter
    private PacketModelEntity packetArmorStandEntity = null;
    @Getter
    private PacketModelEntity packetDisplayEntity = null;

    public BoneTransforms(Bone bone, Bone parent) {
        this.bone = bone;
        this.parent = parent;
    }

    public void transform() {
        updateLocalMatrix();
        updateGlobalMatrix();
    }

    public void updateLocalMatrix() {
        localMatrix.resetToIdentityMatrix();

        Vector3f blueprintModelPivot = bone.getBoneBlueprint().getBlueprintModelPivot();

        // 1. Translate to pivot point
        localMatrix.translateLocal(blueprintModelPivot);

        // 2. Apply rotations (default + animation) with axis corrections
        Vector3f originalRotation = bone.getBoneBlueprint().getBlueprintOriginalBoneRotation();
        localMatrix.rotateLocal(
                originalRotation.get(0),
                originalRotation.get(1),
                originalRotation.get(2)
        );

        // Apply animation rotation
        // Replace your existing animation rotation application with this:
        Vector3f animRot = CoordinateSystemConverter.convertBlockbenchAnimationToMinecraftRotation(
                bone.getAnimationRotation());

        // Apply animation rotation with converted values
        localMatrix.rotateLocal(
                animRot.x,
                animRot.y,
                animRot.z
        );

        // Rest of the method unchanged
        // 3. Scale
        localMatrix.scale(getDisplayEntityScale() / 2.5f);

        // 4. Translate back from pivot point
        localMatrix.translateLocal(blueprintModelPivot.mul(-1));

        // 5. Translate to model center
        localMatrix.translateLocal(bone.getBoneBlueprint().getModelCenter());

        // 6. Apply animation translation
        localMatrix.translateLocal(
                -bone.getAnimationTranslation().get(0),
                bone.getAnimationTranslation().get(1),
                bone.getAnimationTranslation().get(2));

        // 7. Handle parent model center offset
        if (parent != null) {
            Vector3f correctedModelCenter = new Vector3f(parent.getBoneBlueprint().getModelCenter()).mul(-1);
            localMatrix.translateLocal(correctedModelCenter);
        }
    }

    public void updateGlobalMatrix() {
        if (parent == null) {
            Location currentLocation = bone.getSkeleton().getCurrentLocation();
//            boneMatrix.rotateGlobalY((float) Math.toRadians(currentLocation.getYaw()));
//            boneMatrix.rotateGlobalY((float) Math.toRadians(currentLocation.getYaw() + 180));
            localMatrix.translateGlobal((float) currentLocation.getX(), (float) currentLocation.getY(), (float) currentLocation.getZ());
            globalMatrix.getMatrix().set(localMatrix.getMatrix());
        } else {
            //This is where the parent's global matrix is applied to the local matrix
            TransformationMatrix.multiplyMatrices(parent.getBoneTransforms().globalMatrix, localMatrix, globalMatrix);
            //todo: this is going to have to be remade
//            if (bone.getBoneBlueprint().isHead()) {
//                entityMatrix.resetRotation();
//                float yaw = -bone.getSkeleton().getCurrentHeadYaw() + 180;
//                entityMatrix.rotateY((float) Math.toRadians(yaw));
//                entityMatrix.rotateX(-(float) Math.toRadians(bone.getSkeleton().getCurrentHeadPitch()));
//            }
        }
    }

    public void generateDisplay() {
        if (bone.getBoneBlueprint().isDisplayModel()) {
            initializeDisplayEntityBone();
            initializeArmorStandBone();
        }
    }

    private void initializeDisplayEntityBone() {
        if (!DefaultConfig.useDisplayEntitiesWhenPossible) return;
        Location displayEntityLocation = getDisplayEntityTargetLocation();
        packetDisplayEntity = NMSManager.getAdapter().createPacketDisplayEntity(displayEntityLocation);
        if (VersionChecker.serverVersionOlderThan(21, 4))
            packetDisplayEntity.initializeModel(displayEntityLocation, Integer.parseInt(bone.getBoneBlueprint().getModelID()));
        else
            packetDisplayEntity.initializeModel(displayEntityLocation, bone.getBoneBlueprint().getModelID());
        sendDisplayEntityUpdatePacket();
    }

    private void initializeArmorStandBone() {
        //todo: add way to disable armor stands later via config
        packetArmorStandEntity = NMSManager.getAdapter().createPacketArmorStandEntity(getArmorStandTargetLocation());
        if (VersionChecker.serverVersionOlderThan(21, 4))
            packetArmorStandEntity.initializeModel(getArmorStandTargetLocation(), Integer.parseInt(bone.getBoneBlueprint().getModelID()));
        else
            packetArmorStandEntity.initializeModel(getArmorStandTargetLocation(), bone.getBoneBlueprint().getModelID());
        sendArmorStandUpdatePacket();
    }

    protected Location getArmorStandTargetLocation() {
        // Get translation directly from the matrix
        float[] translation = globalMatrix.getTranslation();

        Location armorStandLocation = new Location(
                bone.getSkeleton().getCurrentLocation().getWorld(),
                translation[0],
                translation[1],
                translation[2]
        );

        // Apply armor stand offset
        armorStandLocation.subtract(new Vector(0, BoneBlueprint.getARMOR_STAND_PIVOT_POINT_HEIGHT(), 0));
        return armorStandLocation;
    }

    protected Location getDisplayEntityTargetLocation() {
        // Get translation from global matrix
        float[] translation = globalMatrix.getTranslation();

        return new Location(
                bone.getSkeleton().getCurrentLocation().getWorld(),
                translation[0],
                translation[1],
                translation[2]
        );
    }

    protected EulerAngle getBoneRotationForDisplayEntity() {
        // Use entityMatrix to get the global rotation
        float[] rotation = globalMatrix.getRotation();

        // Apply consistent transformation for display entities
        return new EulerAngle(
                -rotation[0],                 // Invert X
                rotation[1] + (float) Math.PI, // Add 180° to Y
                rotation[2]                   // Keep Z
        );
    }

    protected EulerAngle getBoneRotationForArmorStandEntity() {
        float[] rotation = globalMatrix.getRotation();

        // For all actual bone entities (non-root)
        if (parent != null) {
            // For a 180° Y rotation:
            rotation[0] = -rotation[0];  // Invert X rotation
            rotation[1] = rotation[1] + (float) Math.PI;  // Add 180° to Y
            rotation[2] = -rotation[2];  // Invert Z rotation

            // Normalize Y rotation to keep it in -π to π range
            if (rotation[1] > Math.PI) {
                rotation[1] -= 2 * Math.PI;
            } else if (rotation[1] < -Math.PI) {
                rotation[1] += 2 * Math.PI;
            }
        }

        return new EulerAngle(rotation[0], rotation[1], rotation[2]);
    }

    protected float getDisplayEntityScale() {
        return bone.getAnimationScale() == -1 ? 2.5f : bone.getAnimationScale() * 2.5f;
    }

    public void sendUpdatePacket() {
        sendArmorStandUpdatePacket();
        sendDisplayEntityUpdatePacket();
    }

    private void sendArmorStandUpdatePacket() {
        if (packetArmorStandEntity != null) {
            packetArmorStandEntity.sendLocationAndRotationPacket(getArmorStandTargetLocation(), getBoneRotationForArmorStandEntity());
        }
    }

    private void sendDisplayEntityUpdatePacket() {
        if (packetDisplayEntity != null) {
            packetDisplayEntity.sendLocationAndRotationAndScalePacket(getDisplayEntityTargetLocation(), getBoneRotationForDisplayEntity(), getDisplayEntityScale());
        }
    }

}
